% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/revFun.R
\name{revFun}
\alias{revFun}
\title{Revenue maximization functions for nonconvex technologies}
\usage{
revFun(
  xobs,
  yobs,
  pobs,
  xref = NULL,
  yref = NULL,
  rts = "vrs",
  parallel = FALSE,
  cores = availableCores(omit = 1)
)
}
\arguments{
\item{xobs}{a \eqn{K \times N} matrix with \eqn{K} the number of inputs and
\eqn{N} the number of decision making units (DMUs) under evaluation.}

\item{yobs}{a \eqn{Q \times N} matrix with \eqn{Q} the number of outputs and
\eqn{N} the number of DMUs under evaluation.}

\item{pobs}{a \eqn{Q \times N} matrix of output prices.}

\item{xref}{(optional). a  \eqn{K \times N_r} matrix on inputs of DMUs
serving as benchmark (or use to define the technology).
Default to \code{'xobs'}.}

\item{yref}{(optional). a  \eqn{Q \times N_r} matrix on outputs of DMUs
serving as benchmark (or use to define the technology).
Default to \code{'yobs'}.}

\item{rts}{Character string specifying the returns to scale assumption.
The default value is \code{'vrs'} (variable returns to scale). Other possible
options are \code{'crs'} (constant returns to scale), \code{'nirs'}
(non-increasing returns to scale), or \code{'ndrs'} (non-decreasing returns
to scale).}

\item{parallel}{Logical. Allows parallel computation. If \code{FALSE}
(default), the estimation is conducted in sequential mode. If \code{TRUE},
parallel mode is activated using the number of cores specified in
\code{cores}. When the sample size is small, it is recommended to keep the
\code{parallel} option to its default value (\code{FALSE}).}

\item{cores}{Integer. Used only if \code{parallel = TRUE}. It specifies the
number of cores to be used for parallel computation. By default,
\code{cores = availableCores(omit = 1)}.}
}
\value{
\code{revFun} returns a tibble that contains three columns.
The first column (\code{'RevEff'}), contains the revenue efficiency scores,
the second column (\code{'RevMax'}) contains the maximum revenue and the
third column (\code{'Benchmarks'}) contains the benchmark for each evaluated
observation.
}
\description{
Given a vector of output prices, \code{revFun} estimates the vector of
output quantities that maximizes the revenue subject to different returns to
scale assumptions.
}
\details{
All estimations are based on the implicit enumeration algorithm.
Let's assume that there are \eqn{1,\cdots, N} decision making units (DMUs).
Each DMU uses \eqn{K} inputs to produce \eqn{Q} outputs. The price vector of
the \eqn{Q} outputs is also provided (\eqn{\mathbf{p}}). Therefore, the
enumeration algorithms to obtain the maximum revenue, and hence the revenue
efficiency are detailed next.

\itemize{
\item{variable returns to scale - \code{'vrs'}}{\deqn{R_{max}
\left(\mathbf{p}^\circ,\mathbf{y}^\circ\right)=
\displaystyle\max_{\mathbf{x}^\circ \geq \mathbf{x}_n}
\left\{\mathbf{p}^\circ \mathbf{y}_n\right\}}}

\item{constant returns to scale - \code{'crs'}}{\deqn{R_{max}
\left(\mathbf{p}^\circ,\mathbf{y}^\circ\right)=
\displaystyle\max_{n=1, \cdots, N} \left\{\displaystyle\min_{k=1, \cdots, K}
\left(\frac{x_k^\circ}{x_{kn}}\right) \cdot
 \mathbf{p}^\circ \mathbf{y}_n\right\}}}

\item{nonincreasing returns to scale - \code{'nirs'}}{\deqn{R_{max}
\left(\mathbf{p}^\circ, \mathbf{y}^\circ\right)=
\displaystyle\max_{n=1, \cdots, N} \left\{\min \left\{
\displaystyle\min_{k=1, \cdots, K}\left(
\frac{x_k^\circ}{x_{kn}}\right), 1\right\}
\cdot \mathbf{p}^\circ \mathbf{y}_n\right\}}}

\item{nondecreasing returns to scale - \code{'ndrs'}}{\deqn{R_{max}
\left(\mathbf{p}^\circ, \mathbf{y}^\circ\right)=
\displaystyle\max_{\mathbf{x}^\circ \geq \mathbf{x}_n}
\left\{\displaystyle\min_{k=1, \cdots, K}\left(
\frac{x_k^\circ}{x_{kn}}\right) \cdot
\mathbf{p}^\circ \mathbf{y}_n\right\}}}
}

The revenue efficiency can be obtained as

\deqn{RE=\frac{R_{observed}}{R_{max}}}
}
\examples{
\dontrun{
# variable returns to scale
fdh_rev_vrs <- costFun(xobs = as.matrix(usagri[, c('q.capital', 'q.land',
'q.labor', 'q.materials')]),
yobs = as.matrix(usagri[, c('q.livestock', 'q.crops', 'q.otherout')]),
pobs = as.matrix(usagri[, c('p.livestock', 'p.crops', 'p.otherout')]), rts = 'vrs')

# constant returns to scale
fdh_rev_crs <- costFun(xobs = as.matrix(usagri[, c('q.capital', 'q.land',
'q.labor', 'q.materials')]),
yobs = as.matrix(usagri[, c('q.livestock', 'q.crops', 'q.otherout')]),
pobs = as.matrix(usagri[, c('p.livestock', 'p.crops', 'p.otherout')]), rts = 'crs')

# nondecreasing returns to scale
fdh_rev_ndrs <- costFun(xobs = as.matrix(usagri[, c('q.capital', 'q.land',
'q.labor', 'q.materials')]),
yobs = as.matrix(usagri[, c('q.livestock', 'q.crops', 'q.otherout')]),
pobs = as.matrix(usagri[, c('p.livestock', 'p.crops', 'p.otherout')]), rts = 'ndrs')
}
}
\keyword{models}
\keyword{optimize}
